#import model.user as user
#import model.helper as helper
#import browseDb.main as browseDb
#from threading import Timer
import os

from flask import send_from_directory
from flask import Flask
app = Flask(__name__,)

cwd = os.path.dirname(__file__) + '/'  # get current working directory


@app.route('/favicon.ico')
def favicon():
	"""send the favicon from the typical location at /favicon.ico"""
	return send_from_directory(
		os.path.join(app.root_path, 'static'),
		'favicon.ico',
		mimetype='image/vnd.microsoft.icon',
		cache_timeout=60 * 60 * 24 * 365 * 5,  # set cache timeout to 5 years
	)


# @app.route('/<path:filename>', subdomain="static")
# def static(filename):
# 	"""send static files from separate sub-domain"""
# 	return send_from_directory(
# 		app.static_folder,
# 		filename,
# 	)


@app.route('/')
def index():
	return "<html><head><title>CSD</title></head><body>put docs generated by sphinx here</body></html>"



# urls = (
# 	r'/user(?:/(.*))?', 'UserRequest',
# 	'/db', browseDb.app,
# 	#TODO: add mongs like db browser, with option to only return json (read only?) (restricted - not able to read user collection)
# 	r'/(.*)', 'Static',
# )


# def cron():
# 	"""handles simple cron-like jobs such as rescraping"""
# 	print "cron jobs can be put here"
# 	t = Timer(10000, cron)
# 	t.start()

# cron()


# def processor(handler):
# 	"""app processor for setting contextual vars and dealing with output of script"""
# 	web.ctx.user = user.Instance()
# 	web.ctx.dev = (web.input(dev='False').dev == 'True')  # if ?dev=True then dev will be set to True, otherwise it defaults to False
# 	web.ctx.notify = []  # an array that holds notifications (like non-fatal errors or important messages)

# 	inputs = web.input(username='', token='')
# 	#only run user.check if username and token are defined... still allows use of default guest account
# 	if inputs.username != '' and inputs.token != '':
# 		try:
# 			web.ctx.user.check(username=inputs.username, token=inputs.token)  # validate user token if username and token are supplied
# 		except Exception as error:
# 			return helper.json_dump(helper.error_dump(error))  # needs json dump wrapper because returns done here won't get processed

# 	response = handler()

# 	if type(response) in (dict, tuple, list):
# 		response = helper.json_dump(response)  # format the response in json if it is a variable (not html being returned)

# 	return response

# app.add_processor(processor)



# def userRequest(self, name=''):
# 	""" handles requests for user data, logins, and signups """
# 	if name == None or name == '':
# 		return web.ctx.user.safe_data()
# 	elif name == 'login':
# 		#CONSIDER: add a delay to prevent excessive attempts
# 		inputs = web.input(username='', email='', password='')
# 		try:
# 			web.ctx.user.login(username=inputs.username, email=inputs.email, password=inputs.password)
# 		except Exception as error:
# 			return helper.error_dump(error)

# 		return helper.json_dump({'token': web.ctx.user.data['session']['token']})

# 	elif name == 'signup' or name == 'update':  # signup and update are basically the same thing
# 		inputs = web.input(data={})
# 		try:
# 			web.ctx.user.update(inputs.data)
# 		except Exception as error:
# 			return helper.error_dump(error)
# 		return {'notify': 'update successful'}

# 	else:
# 		return web.application.notfound(app)  # this means it is not one of the defined methods for interacting w/ the server


# def static(filename):
# 	"""
# 		searches for and returns a requested static file or 404s out
# 		this allows files in /static to be accessed as if they were in /
# 	"""
# 	try:
# 		return open(cwd + 'static/' + filename, 'r').read()
# 	except:
# 		web.application.notfound(app)  # file not found


if __name__ == "__main__":
	app.run(debug=True)
